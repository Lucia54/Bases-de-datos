# -*- coding: utf-8 -*-
"""3. Clasificador bayesiano

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oEJCdYp3ZV2hqoK7oHz5nuQxBP6LF9N2

CLASIFICACIÓN BAYESIANA

Los modelos Naive Bayes son un grupo de algoritmos de clasificación extremadamente rápidos y sencillos de entrenar que suelen ser adecuados para conjuntos de datos de muy alta dimensión. 

Como son tan rápidos y tienen tan pocos parámetros ajustables, acaban siendo muy útiles como modelos de referencia en el proceso de elaboración de modelos sofisticados para resolver problemas de clasificación.

Los clasificadores Naive Bayes se basan en métodos de clasificación bayesianos, es decir, fundamentados matemáticamente en el Teorema de Bayes.

Vamos a operar de diferentes maneras con los préstamos de nuestro banco, en concreto vamos a intentar crear clasificadores para que dadas unas variables nos den la probabilidad o el rating de darle un préstamo a un cliente

## Carga de Datos
"""

!gdown --id 1Osmr7qVN0NMuqYxvLesNn7H4nqPCVbsU

"""1. Cargamos la extensión sql"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext sql

"""2. Nos conectamos con la base de datos"""

# Commented out IPython magic to ensure Python compatibility.
# %sql sqlite:///data_berka.db

"""> Datos de préstamos ya finalizados con su estado final, incluyendo datos del distrito, etc.

¿Cuántos préstamos hay por cada estado (status)?
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT DISTINCT status, count (*) as total
# FROM loan
# GROUP BY status
# ORDER BY total DESC

"""Vamos a empezar obteniendo los datos de los préstamos ya finalizados. Van a ser nuestros datos de entrenamiento. Por lo que seleccionaremos únicamente aquellos préstamos en status 'A' o 'B'. 

Con una sentencia CASE vamos a poner los prestamos finalizados bien a 1 y los que no finalizaron bien a 0. 

Sintaxis de uso de [INNER JOIN](https://www.sqlitetutorial.net/sqlite-inner-join/) para establecer joins entre tablas

Substr: para tratar las fechas.
La expresión de los join: son inner join (intersecciones). 
CASE: típica sentencia del lenguaje de programación. A partir de distintos casos establece distintos valores de salida. Según la variable status cuando sea A ponemos un 1 y cuando sea B ponemos un 0. Se suele hacer con una sola variable y con una numeración controlada.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql loans_train << SELECT substr(l.date,0,3) year, amount, duration, payments, A11, A13,
#   CASE status WHEN 'A' THEN 1
#               WHEN 'B' THEN 0
#   END label
#   FROM LOAN l, ACCOUNT a INNER JOIN DISTRICT d on a.district_id = d.A1 
#   WHERE l.account_id = a.account_id and l.status in ("A", "B")

"""3. Obtenemos el DataFrame"""

df_train = loans_train.DataFrame()
df_train.head()

"""Comprobamos la forma, tenemos 234 filas y 7 columnas"""

df_train.shape

"""Para la parte de test lo que vamos a extraer de la base de datos son los préstamos que están en ejecución (status in ("C","D")) con los mismos campos que en la consulta anterior (si modificamos una debemos modificar la otra)."""

# Commented out IPython magic to ensure Python compatibility.
# %%sql loans_test << SELECT substr(l.date,0,3) year, amount, duration, payments, A11, A13,
#   CASE status WHEN 'C' THEN 1
#               WHEN 'D' THEN 0
#   END label
#   FROM LOAN l, ACCOUNT a INNER JOIN DISTRICT d on a.district_id = d.A1 
#   WHERE l.account_id = a.account_id and l.status in ("C", "D")

"""Ejercicio: Añadir la edad del cliente propietario de la cuenta del prestamo y algún campo de datos demográficos adicionales (no nombre de región pero si los demás). 

"""

df_test = loans_test.DataFrame()
df_test.head()

"""4. División de los datos en entrenamiento y test

'features' es una variable de tipo lista que me almacena características que me sirven como entrada.
"""

features = ["year", "amount", "duration", "payments","A11", "A13"]

"""*train (creación del modelo): datos de préstamos ya finalizados. 
*test (evaluación del modelo): datos de préstamos en ejecución. 
"""

X_train = df_train[features]
y_train = df_train["label"]

X_test = df_test[features]
y_test = df_test["label"]

"""5. Normalizarlos puede ser una buena medida para obtener mejores resultados.
Para ello vamos a utilizar el [StandardScaler](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html)

El centrado y el escalado se realizan de forma independiente en cada característica, calculando las estadísticas pertinentes en las muestras del **conjunto de entrenamiento**. La media y la desviación estándar se almacenan para utilizarlas en datos posteriores mediante una **transformación**.

Mas información sobre normalización en el siguiente [enlace](https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler)

"""

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
# calculo de los factores de centrado y escalado
scaler.fit(X_train) 
# transformación
X_train = scaler.transform(X_train)
X_test = scaler.transform(X_test)

"""Aplicamos un modelo [NaiveBayes](https://scikit-learn.org/stable/modules/naive_bayes.html?highlight=naive+bayes) para construir un clasificador de préstamos"""

from sklearn.naive_bayes import GaussianNB #, MultinomialNB, BernoulliNB, ComplementNB

gnb = GaussianNB()
clf = gnb.fit(X_train, y_train)
y_pred = clf.predict(X_test)
print("Número de préstamos clasificados erroneamente %d de un total de  %d"  % (X_test.shape[0], (y_test != y_pred).sum()))

"""Para ver que resultados tenemos sobre la colección de `test` utilizamos en primer lugar el informe de los resultados [`classification report`](https://scikit-learn.org/stable/modules/model_evaluation.html#classification-report)

Classification_report: mide las medidas necesarias para saber si lo que hemos hecho ha funcionado bien o mal (forma de evaluar).
"""

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred, labels=clf.classes_))

"""Y la [matriz de confusión](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.ConfusionMatrixDisplay.html)
Si un clasificador dice que el préstamo va a ser impagado debemos comprobarlo con la situación real.
La diagonal principal indica los aciertos (27 y 298). 
Los errores son los demás valores (18 y 105).
Se puede utilizar para cualquier resolución de modelos de clasificación. El problema es que dice que hay más impagos de los que hay en realidad por lo que hay que tener en cuenta que los errores dependen de los problemas que se estudien. 

"""

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
cm = confusion_matrix(y_test, y_pred, labels= clf.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=clf.classes_)
disp.plot()

"""**Ejercicios**

Plantear el clasificador de préstamos añadiendo datos de otras tablas de la base de datos, u otros campos de las mismas tablas (edad del cliente, etc).

Otras transformaciones: [Discretización](https://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-discretization) y utilización de otros clasificadores NB

Seleccionamos las variables que queremos utilizar:
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql loans_train << SELECT substr(l.date,0,3) year, amount, duration, payments, A11, A13,
#   CASE status WHEN 'A' THEN 1
#               WHEN 'B' THEN 0
#   END label
#   FROM LOAN l, ACCOUNT a INNER JOIN DISTRICT d on a.district_id = d.A1 
#   WHERE l.account_id = a.account_id and l.status in ("A", "B")

df_train = loans_train.DataFrame()
df_train.head()