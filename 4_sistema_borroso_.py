# -*- coding: utf-8 -*-
"""4. Sistema borroso.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13KPb4rbXFJUbaXS-L3dmKWR1lOzIR_03

Vamos a operar de diferentes maneras con los préstamos de nuestro banco, en concreto vamos a intentar crear clasificadores para que dadas unas variables nos den la probabilidad o el rating de darle un préstamo a un cliente

## Carga de Datos
"""

!gdown --id 1Osmr7qVN0NMuqYxvLesNn7H4nqPCVbsU

"""1. Cargamos la extensión sql"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext sql

"""2. Nos conectamos con la base de datos"""

# Commented out IPython magic to ensure Python compatibility.
# %sql sqlite:///data_berka.db

"""> Datos de préstamos ya finalizados con su estado final, incluyendo datos del distrito, etc.

Averiguamos los rangos de valores de los préstamos actuales del banco
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql loans << SELECT substr(l.date,0,3) year, amount, duration, payments, A11, A13,
#   CASE status WHEN 'A' THEN 1
#               WHEN 'B' THEN 0
#               WHEN 'C' THEN 1
#               WHEN 'D' THEN 0
#   END label
#   FROM LOAN l, ACCOUNT a INNER JOIN DISTRICT d on a.district_id = d.A1 
#   WHERE l.account_id = a.account_id

"""3. Obtenemos el DataFrame"""

df = loans.DataFrame()
df.head()

"""4. División de los datos en entrenamiento y test"""

X = df[["year", "amount", "duration", "payments","A11", "A13"]]
y = df["label"]

import numpy as np
X = np.asarray(X).astype(np.float32)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1)

"""# Sistema Borroso

Vamos a crear un sistema de control borroso que modela cómo se puede evaluar la capacidad de un cliente para pedir un préstamo. Cuando se tiene que dar un préstamos se considerará la edad del peticionario, la cantidad del préstamos, la duración y los pagos en los que se divide. FInalmente nos dará una puntuación de 0 a 10 al préstamo.

## Preliminares

https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_tipping_problem_newapi.html#example-plot-tipping-problem-newapi-py

* instalación de scikit-fuzzy
"""

# https://pythonhosted.org/scikit-fuzzy/
!pip install -U scikit-fuzzy

"""* importación de librerías

"""

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl

"""##  Sistema Borroso

Los Antecedentes van a ser Edad, duración, pagos, y cantidad. Vamos a ver como se comportan estos valores en nuestra base de datos
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT min(duration), max(duration), min(payments), max(payments), min(amount), max(amount)
# FROM LOAN
#

"""**Atención a la subconsulta en el FROM**"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql 
# SELECT min(edad), max(edad)
# FROM (
# SELECT 99 - substr(birth_number,0,3) edad
# FROM CLIENT
# )
# 
#

"""
Definimos los Antecedentes mediante variables lingüísticas con un máximo y un mínimo y una serie de etiquetas para estas variables
"""

payments = ctrl.Antecedent(np.arange(200, 10000, 1), 'payments')
payments.automf(3)
payments.view()

age = ctrl.Antecedent(np.arange(20,90, 1), 'age')
#age.automf(3, names = ["very young", "young", "old"])
age['very young'] = fuzz.trapmf(age.universe, [20, 20, 30, 50])
age['young'] = fuzz.trimf(age.universe, [30, 50, 70])
age['old'] = fuzz.trapmf(age.universe, [50, 70, 90, 90])
age.view()

duration = ctrl.Antecedent(np.arange(12, 60, 1), 'duration')
duration.automf(3, names=["short", "average", "long"])
duration.view()

amount = ctrl.Antecedent(np.arange(5000, 600000, 1), 'amount')
amount.automf(3,  names = ["low","average","high"])
amount.view()

"""Definimos el consecuente"""

rate = ctrl.Consequent(np.arange(0, 100, 1), 'rate')
rate.automf(3)
rate.view()

"""## Reglas borrosas
-----------
Ahora, para hacer estos triángulos útiles, definimos la *relación borrosa*
entre las variables de entrada y salida. Para el ejemplo vamos a considerar las siguientes reglas simples (para hacer un sistema completo se necesitarían algunas más) 

1. Si la duración y la cantidad son pequeñas entonces la calificación será buena.
2. Si la cantidad es alta, los pagos pequeños y la duración alta entonces la calificación será *pobre*
3. Si la cantidad es media y los pagos también medios si la edad del cliente es baja entonces el rating es medio. 

La clave de estas reglas es que son borrosas, es decir que expresamos la información de forma lingüística intentando manejar la incertidumbre inherente. 


"""

rule1 = ctrl.Rule(duration['short'] & amount['low'], rate['good'])
rule2 = ctrl.Rule(amount['high'] & payments['average'] & duration["long"], rate["poor"])
rule3 = ctrl.Rule(age['young'] & amount['average'], rate['average'])

rule1.view()

from google.colab import widgets

def show_rule(rule):
  grid = widgets.Grid(1, len(rule.antecedent_terms) + 1)
  i = 0
  for t in rule.antecedent_terms:
    with grid.output_to(0, i):
      t.view()
    i+=1  
  # show consequent  
  with grid.output_to(0, i):
    rule1.consequent[0].term.view()

show_rule(rule1)
show_rule(rule2)
show_rule(rule3)

"""### Ejecución

Ahora que tenemos nuestras reglas definidas, podemos simplemente crear un sistema de control vía:
"""

rating_ctrl = ctrl.ControlSystem([rule1, rule2, rule3])

"""Con el fin de simular este sistema de control, crearemos un
"Sistema de Control y Simulación".  Este objeto que representa al controlador aplicado a un conjunto específico de circunstancias.  
"""

rating = ctrl.ControlSystemSimulation(rating_ctrl)

"""Ahora podemos simular nuestro sistema de control simplemente especificando las entradas y llamando al método *compute*.  

Supongamos que un cliente de 40 años va a pedir un préstamos a 12 años con pagos de 2000 y una cantidad de 300000
"""

#@title Datos Básicos {run: "auto"}
rating.input['age'] = 63 #@param {type:"slider", min:25, max:100, step:1}
rating.input['duration'] = 60 #@param { type: "slider", min: 12 , max: 60, step: 1}
rating.input['payments'] = 2000  #@param { type: "slider", min: 0 , max: 10000, step: 1000}
rating.input['amount'] = 500000 #@param { type: "slider", min: 0 , max: 600000, step: 10000}

rating.compute()
print(rating.output['rate'])
rate.view(sim=rating)