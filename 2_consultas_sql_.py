# -*- coding: utf-8 -*-
"""2. Consultas SQL.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BH86iJpJ6B255G68H5ZYJFcl_QxYYKSg

# Consultas SQL

*SQL (Structured Query Language)*
Es el lenguaje más universalmente usado para bases de datos relacionales.
- Las consultas de selección se utilizan para indicar al motor de datos que devuelva información de las bases de datos. 
- Esta información es devuelta en forma de conjunto de registros que se pueden almacenar en una nueva tabla.

Antes de empezar cargamos nuestro archivo data_berka en nuestro entorno: [enlace](https://sorry.vse.cz/~berka/challenge/pkdd1999/berka.htm)
"""

!gdown --id 1Osmr7qVN0NMuqYxvLesNn7H4nqPCVbsU

"""En primer lugar cargamos la extensión que nos va permitir manejar comandos sql directamente en colab

"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext sql

"""Y conectamos con la base de datos"""

# Commented out IPython magic to ensure Python compatibility.
# %sql sqlite:///data_berka.db

"""Comprobamos esquema"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT name,type
# FROM sqlite_master
# WHERE type = 'table' #"Dime las tablas que hay dentro de la base de datos."

"""## Consultas sobre Préstamos

Operadores:
- Not: negación, por ejemplo, cuando queremos que una condición no se cumpla.
- Like: para consultar sobre cadenas de caracteres y sirve también para hacer búsquedas aproximadas.
- Order by: para especificar el orden en el que se desean recuperar los registros de la tabla.
- Limit: donde queremos que pare (tope).
- Distinct: omite repeticiones de registros cuyos campos seleccionados coincidan totalmente. 


Estos operadores se pueden unir y utilizarlos conjuntamente (es lo que se suele hacer pero para empezar es mejor ir paso a paso).

1. Obtener todos los atributos que tiene el banco sobre sus préstamos.

(extra limitar a 20 registros)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT* #El * sobre SELECT es para obtener todas las consultas de la tabla.
# FROM LOAN
# LIMIT 20

"""2. Obtener los campos de fecha (date), amount (cantidad), duración (duration), pagos (payments), estado (estado)

(extra limitar a 20 registros)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT date, amount, duration, payments, status
# FROM LOAN
# ORDER BY amount DESC #Ordenamos de forma descendiente.
# LIMIT 20 #Le ponemos el límite en 20 registros.

"""3. Obtener los distintos tipos de estado que se presentan en un préstamo."""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT DISTINCT status
# FROM LOAN
# ORDER BY status #Ahora ordenamos en función del estado del préstamo.

"""4. Obtener solo los prestamos ya terminados, ordenar por duración y cantidad.


Extra: limitar a 20 elementos. 
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT*
# FROM LOAN
# WHERE status in ("A","B") #Seleccionamos los préstamos ya terminados. 
# ORDER BY duration, amount #Ordenamos por duración y cantidad.
# LIMIT 20 #Establecemos el límite en 20 observaciones.

"""Cargar el resultado de la sql en un Data Frame de Pandas."""

#Importar la librería
import pandas as pd
#Ejecutar sql
df = %sql SELECT*FROM LOAN WHERE status in ("A", "B") ORDER BY duration, amount DESC
#Transformar en Data Frame de pandas y descargarlo en un csv.
df.DataFrame().to_csv("first_sql.csv")

""" Ex. 2 

> Seleccionar fecha, cantidad, duración y pagos de aquellos préstamos que han sido terminados con una duración mayor de 12 meses ordenados de mayor a menor cantidad de dinero


"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT date, amount, duration, payments
# FROM LOAN
# WHERE status in ("A", "B") AND duration >12
# ORDER BY amount DESC

"""¿Cuántos registros cumplen esa condición?"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT count(*)
# FROM LOAN
# WHERE status in ("A", "B") AND duration >12

"""¿Cuántos préstamos hay en ejecución (running) con una duración comprendida entre 24 y 48 meses?"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT count(*)
# FROM LOAN
# WHERE status in ("C", "D") AND duration between 24 and 48

"""## Group By

- Group by combina los registros con valores idénticos para lista campos en un grupo, para el que se mostrará un único registro. 
- Hace agregaciones y las añade para obtener valoresa agregados.

7. ¿Cuántos préstamos hay por cada estado y cual es la media de la cantidad de dinero prestado?

IMPORTANTE:
- WHERE: se filtran los registros antes de agruparlos.
- HAVING: se filtran los grupos tras obtenerlos.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT status, count(*) as total, avg(amount)
# FROM LOAN
# WHERE duration >=24
# GROUP BY status
# HAVING total>25
# ORDER BY total DESC

"""---

8. Por cada Región, quiero contar el número de ciudades y obtener el total del número de habitantes de la región

Extra: no considerear la región de Praga.


"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT*FROM DISTRICT

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# #Seleccionamos la consulta y añadimos los nombres con los que queremos que salgan los resultados. 
# SELECT A3, count(A2) no_districts, sum(A9) no_cities, sum(A4) total_hab
# FROM DISTRICT
# WHERE NOT A3="Prague"
# GROUP BY A3

"""De la tabla DISTRICT sacamos los habitantes de las ciudades (con mayor o igual a 10) ordenados de forma descendiente."""

# Commented out IPython magic to ensure Python compatibility.
# %%sql 
# SELECT A3, COUNT(A4) as Ciudades, SUM(A4) as Habitantes
# FROM DISTRICT
# GROUP BY A3
# HAVING Ciudades >= 10
# ORDER BY Habitantes DESC
#

"""---

9. Contar ordenes permanentes (domiciliaciones) por banco y tipo de transacción
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT bank_to, k_symbol, count(*) as c
# FROM PERMANENT_ORDER
# WHERE amount < 500
# GROUP BY bank_to, k_symbol
# ORDER BY bank_to
# 
# 
#

"""# JOIN

10. ¿Cuántas cuentas de frecuencia mensual tienen un un préstamo activo?
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT count(*) as Cuenta
# FROM  LOAN l, ACCOUNT a
# WHERE l.account_id = a.account_id
# and frequency = "monthly"
# and status in("C","D")
#

# Commented out IPython magic to ensure Python compatibility.
# #Añade más campos
# %%sql
# SELECT loan_id, A4, A9, A10, A11,SUBSTR(c.birth_number,0,3) birthyear, l.date loan_date, amount, duration, payments, frequency, a.date acc_date, status 
# FROM LOAN l, ACCOUNT a, DISTRICT d, DISPOSITION dp, CLIENT c
# WHERE l.account_id = a.account_id
# AND a.district_id = d.A1
# AND dp.account_id = a.account_id -- join disposition y account
# AND dp.client_id = c.client_id  -- join disposition y client
# AND dp.type = "OWNER"
# AND status in ("A", "B")
# ORDER BY amount DESC, a.date DESC
# LIMIT 10

"""11. Domiciliaciones en cuentas de actualización semanal de alquiler en cuentas de Praga"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT order_id, p.account_id, amount
# FROM PERMANENT_ORDER p, ACCOUNT a, DISTRICT d
# WHERE p.account_id = a.account_id
# and a.district_id = d.A1
# and k_symbol = "LEASING"
# and frequency = "weekly"
# and A3 = "Prague"
# 
#

"""**Ejercicio**

12. Domiciliaciones (*órdenes*) semanales para alquiler (*leasing*) en cuentas de Praga

- Ordenes permanentes de alquiler (*leasing*) y semanales (*weekly*)
- Relación con cuentas que tienen región Praga
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT order_id, k_symbol, bank_to, a.account_id, a.frequency, d.A2, d.A3
# FROM PERMANENT_ORDER p, ACCOUNT a, DISTRICT d
# WHERE p.account_id = a.account_id and a.district_id = d.A1
#     and k_symbol = "LEASING" and a.frequency = "weekly" and d.A3 = "Prague"

"""**Ejercicio**

13. Transacciones relacionadas con pensiones (DUCHOD) en Plzen desde el banco MN

(limitar a 10)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT trans_id, a.account_id, a.frequency, t.type, k_symbol, bank
# FROM TRANS t, ACCOUNT a, DISTRICT d
# WHERE t.account_id = a.account_id and a.district_id = d.A1
#   and k_symbol = "DUCHOD" and bank = "MN" and d.A2 like "Plzen%"  
# LIMIT 10
#

"""# Subconsultas

14. Prestamos cuya cantidad es superior a la media de los clientes de Praga

- Cantidad media prestada a los cuentas de Praga de Praga
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT avg(l.amount)
# FROM LOAN l, ACCOUNT a, DISTRICT D
# WHERE l.account_id = a.account_id and a.district_id = d.A1 
# and d.A3 = "Prague"
#

"""- Consultar los préstamos superiores a esa cantidad"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT * FROM LOAN 
# WHERE amount > (SELECT avg(l.amount)
#         FROM LOAN l, ACCOUNT a, DISTRICT d
#         WHERE l.account_id = a.account_id and a.district_id = d.A1  
#         and d.A3 = "Prague")
# ORDER BY amount DESC
#



"""# Repaso de Join/Group By

## Objetivo 2.1

15. Clientes de Praga con préstamos según su estado

- ¿Cuántos clientes hay en Praga?
- ¿Cuántas cuentas tienen asociados clientes en Praga?
- ¿cuántas de esas cuentas tienen asociados un préstamo?
- Necesito saber cuántos hay por cada estado (*status*)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql 
# SELECT status, count(*)
# FROM CLIENT c, DISTRICT d, DISPOSITION dp, LOAN l 
# WHERE c.district_id = d.A1 and c.client_id = dp.client_id
# and l.account_id = dp.account_id and d.A3 = "Prague"
# GROUP BY status
#

"""## Ejercicio

16. Cantidad de dinero medio en transacciones de clientes propietarios de cuentas en Kolin (owned accounts)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT c.client_id, avg (amount) as av
# from client c, district d, disposition ds, account a, trans t
# WHERE c.district_id = d.A1 and c.client_id = ds.client_id
#     and ds.account_id = a.account_id and a.account_id = t.account_id
# and d.A2 = "Kolin" and ds.type = "OWNER" 
# GROUP BY c.client_id
# ORDER BY av DESC
# LIMIT 10
# 
#

"""> sanction interest if negative balance Cesky Krumlov


> stands for loan payment in Praha from the bank EF

# Extra: Left Join

1. ¿Cuántas cuentas hay? 4500
2. ¿Cuántas cuentas hay con préstamos? (inner join) 682
3. Cuentas con los datos de los préstamos si los hay
4. los ordenamos por cantidad
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql 
# SELECT a.account_id, a.date, l.amount, l.status, l.payments, l.duration
# FROM ACCOUNT a INNER OUTER JOIN LOAN l ON a.account_id = l.account_id
# ORDER BY amount DESC
# 
# 
#

"""# DataSets

---

17. Dataset sobre las transacciones con Vyskov, extrayendo los años de las diferentes fechas.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%sql dataset << SELECT substr(a.date,0,3) acc_year, substr(t.date, 0, 3) year,amount, balance, k_symbol
# FROM ACCOUNT a, TRANS t, DISTRICT d
# WHERE a.district_id = d.A1 and d.A2 = "Vyskov"
# AND a.account_id = t.account_id
#

dataset.DataFrame().to_csv("dataset.csv")